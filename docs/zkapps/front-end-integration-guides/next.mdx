---
title: Next JS and GitHub Pages
description: Getting started with Next
keywords:
  - next
  - ui
  - sharedarraybuffer
---

# Next JS Integration Guide
## Install a Wallet

- Install a wallet that supports zkApp transactions. For this tutorial, we’ll use **Auro Wallet**. [Download it here](https://www.aurowallet.com/).
- Add the Auro Wallet browser extension.
- Open the extension and follow the steps to create a new wallet.
- Click **"Mainnet"** at the top of the extension view, then select **"Show Testnet"** from the menu. After that, select **"Devnet"**.
    - Using Devnet will allow us to interact with a test version of the Mina network without needing to spend real Mina to pay for transaction fees.
- Fund your wallet using the [Mina Faucet](https://faucet.minaprotocol.com/).
    - You'll need to wait one block (~3 minutes) to see the change in balance reflected on chain. You can use [Minascan](https://minascan.io/devnet) to track the status of your transaction.

## Initialize the Project

We will follow the project initialization workflow from the [NextJS docs](https://nextjs.org/docs/app/getting-started/installation).  This tutorial uses version 15, but the same concepts should apply to all versions of Next.

- Create a new project by running:

```bash
npx create-next-app@15.1.4
```

For this tutorial, I have selected the following options:

```
✔ What is your project named? … next-js-integration-guide
✔ Would you like to use TypeScript? … Yes
✔ Would you like to use ESLint? … Yes
✔ Would you like to use Tailwind CSS? … Yes
✔ Would you like your code inside a `src/` directory? … Yes
✔ Would you like to use App Router? (recommended) … Yes
✔ Would you like to use Turbopack for `next dev`? … No
✔ Would you like to customize the import alias (`@/*` by default)? … No
```

- Install o1js

For this tutorial, we are using o1js version 2.

```bash
npm i o1js@^2
```

- Make sure that everything is working by running the development server

```bash
npm run dev
```

## Configure the app for effective o1js usage

This section will walk through the basics of configuring a Next.js app to work with o1js.  The two main points are:

- Set the COOP and COEP headers so that o1js can communicate with the shared array buffer used by WASM
- Set up some web worker infrastructure so that long-running o1js computation does not block rendering your site

### Update headers in next config

To set the COOP and COEP headers correctly in next, edit your `next.config.ts` file to match the snippet below:

```ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  async headers() {
    return [
      {
        source: "/(.*)",
        headers: [
          {
            key: "Cross-Origin-Opener-Policy",
            value: "same-origin",
          },
          {
            key: "Cross-Origin-Embedder-Policy",
            value: "require-corp",
          },
        ],
      },
    ];
  },
};

export default nextConfig;
```

TODO: can we also test using vercel.json to do the same thing?

### Use Comlink to create a worker

We strongly recommend using web workers in your o1js-enabled apps.  Comlink is a package which wraps web workers in a convenient API, and I will use it for this guide, but any way of using web workers that you're comfortable with will work.

To use Comlink, first install it:

```bash
npm i comlink
```

Then, create a worker, and a workerClient file.  For this app, I will call the filed `todoListWorker.ts` and `todoListWorkerClient.ts`.

```bash
touch src/app/todoListWorker.ts src/app/todoListWorkerClient.ts
```

For now, let's put some boilerplate in these files:

```ts
// todoListWorker.ts

import * as Comlink from "comlink";

export const api = {
  async sayHi() {
    return "Hello from the worker!";
  }
};

Comlink.expose(api);
```

```ts
// todoListWorkerClient.ts

import * as Comlink from "comlink";

export default class TodoListWorkerClient {
  worker!: Worker;
  remoteApi: Comlink.Remote<typeof import("./todoListWorker").api>;

  constructor() {
    const worker = new Worker(new URL("./todoListWorker.ts", import.meta.url), {
      type: "module",
    });
    this.remoteApi = Comlink.wrap(worker);
  }

  async sayHi() {
    return await this.remoteApi.sayHi();
  }
}
```

### Set any page that needs access to the web worker to 'use client' mode

Only client-side rendered code will have access to web workers.  Server-rendered components don't have access to browser features.  In order to make use of web workers, tell next that your component should be client-rendered with `'use client'` on `page.tsx`.

```diff
// page.tsx

+ 'use client'
import Image from "next/image";

export default function Home() {
  return (
```

Then, import the web worker and confirm that it is working:

```diff
'use client'
import Image from "next/image";
+ import TodoListWorkerClient from "./todoListWorkerClient";

export default function Home() {
+  const workerClient = new TodoListWorkerClient();
+  workerClient.sayHi().then((message) => {
+    console.log(message);
+  });
  return (
```

Confirm that you see the message logged in your browser by opening the dev tools (F12) and looking for 'Hello from the worker!'.

Now we have our web worker set up and we're ready to add logic to our app!

## Write the provable code that you want to execute in browser

The rest of the guide will go through specifically how to write a todolist program with o1js and run it in the browser using the Next.js config that we just set up.

The first step is writing a `ZkProgram`.  `ZkProgram` is how proofs are created in o1js.  Generating the proof is done in javascript, either in node, or in a browser, and verifying the proof can be done in javascript as well, or on a network like Mina, Protokit or Zeko.

Let's get started by creating a new file called `zkTodoList.ts` and describing our program:

```bash
mkdir -p src/lib && touch src/lib/zkTodoList.ts
```

```ts
// zkTodoList.ts

import { Experimental, ZkProgram } from "o1js";

export { IndexedMerkleMap8, ZkTodoList, ZkTodoListProof };

class IndexedMerkleMap8 extends Experimental.IndexedMerkleMap(8) {}

const ZkTodoList = ZkProgram({
  name: "TodoList",
  publicOutput: IndexedMerkleMap8,
  methods: {},
});

class ZkTodoListProof extends ZkProgram.Proof(ZkTodoList) {}
```

- `class IndexedMerkleMap8 extends Experimental.IndexedMerkleMap(8) {}`
  - This line creates the class we will use to store our todo list
  - IndexedMerkleMap(8) means a merkle map with 2^8 leaves that can be accessed by index
- `publicOutput: IndexedMerkleMap8,`
  - This line defines the type of the output of the proof as our indexed merkle map class
  - So every proof of the contents of a todolist will export the merkle map that it is valid for

Next let's add the data structure for a todo item.  We want to track the text of the todo and the status, whether it's been completed or not.

```diff
export { 
  IndexedMerkleMap8, 
+  Todo, 
  ZkTodoList, 
  ZkTodoListProof 
};

class IndexedMerkleMap8 extends Experimental.IndexedMerkleMap(8) {}

+ class Todo extends Struct({
+   text: CircuitString,
+   status: Bool,
+ }) {
+   hash() {
+     return Poseidon.hash([this.text.hash(), this.status.toField()]);
+   }
+ }

const ZkTodoList = ZkProgram({
```

Finally, let's add methods to our program to handle initializing, adding a todo, and completing a todo.

```diff
const ZkTodoList = ZkProgram({
  name: "TodoList",
  publicOutput: IndexedMerkleMap8,
  methods: {
+     init: {
+       privateInputs: [],
+       method: async () => {
+         const publicOutput = new IndexedMerkleMap8();
+         return { publicOutput };
+       },
+     },
+     addTodo: {
+       privateInputs: [SelfProof, Field, Todo],
+       method: async (
+         p: SelfProof<undefined, IndexedMerkleMap8>,
+         index: Field,
+         todo: Todo
+       ) => {
+         p.verify();
+         const publicOutput = p.publicOutput.clone();
+ 
+         publicOutput.insert(index, todo.hash());
+         return { publicOutput };
+       },
+     },
+     completeTodo: {
+       privateInputs: [SelfProof, Field, Todo],
+       method: async (
+         p: SelfProof<undefined, IndexedMerkleMap8>,
+         index: Field,
+         todo: Todo
+       ) => {
+         p.verify();
+         const publicOutput = p.publicOutput.clone();
+         publicOutput.get(index).assertEquals(todo.hash());
+         todo.status = Bool(true);
+         publicOutput.update(index, todo.hash());
+         return { publicOutput };
+       },
+     },
+   },
});
```

That should do it for our example!  Let's get back to the web application and integrate this new feature.

## Wrap ZkProgram functionality in the web worker

Back in our web worker, we will now want to expose the funcitonality of the todo list program to the Next.js application.

Since we already set the worker up properly, this part is very straightforward.  We simply need to import the zk program and write new methods for the worker that correspond to the features.

We will also track some state in the web worker for convenience.

```ts
// todoListWorker.ts

import { Bool, CircuitString, Field } from "o1js";
import * as Comlink from "comlink";
import {
  IndexedMerkleMap8,
  Todo,
  ZkTodoList,
  ZkTodoListProof,
} from "../lib/zkTodoList";

export type TodoObjectRepr = {
  text: string;
  status: boolean;
};

const state = {
  merkleMap: null as IndexedMerkleMap8 | null,
  objectRepr: {} as Record<number, TodoObjectRepr>,
  proof: null as ZkTodoListProof | null,
  index: 0,
};

export const api = {
  async init() {
    console.time("Compiling zkTodoList");
    await ZkTodoList.compile();
    console.timeEnd("Compiling zkTodoList");
    const initialProof = await ZkTodoList.init();
    state.proof = initialProof.proof;
    state.merkleMap = initialProof.proof.publicOutput;
  },
  async addTodos(todos: Array<string>) {
    if (!state.proof) {
      throw new Error("Proof not initialized");
    }
    let i = 0;
    while (todos.length > 0) {
      const text = todos.shift()!;
      console.log("Adding todo", i, text);
      const todo = new Todo({
        text: CircuitString.fromString(text),
        status: Bool(false),
      });
      const index = Field(state.index + 1);
      const proof = await ZkTodoList.addTodo(state.proof, index, todo);
      state.merkleMap = proof.proof.publicOutput;
      state.index++;
      i++;
      state.objectRepr[state.index] = { text, status: false };
      state.proof = proof.proof;
    }
  },
  async completeTodo(index: number) {
    if (!state.proof || !state.merkleMap) {
      throw new Error("Proof not initialized");
    }
    try {
      const todoHash = state.merkleMap.get(Field(index));

      console.log("Completing todo", index, todoHash);
    } catch (e) {
      throw new Error("Todo not found");
    }

    const todoRepr = state.objectRepr[index];
    if (!todoRepr) {
      throw new Error("Todo not found");
    }
    if (todoRepr.status) {
      throw new Error("Todo already completed");
    }

    const todo = new Todo({
      text: CircuitString.fromString(todoRepr.text),
      status: Bool(todoRepr.status),
    });

    const text = todo.text.toString();
    const proof = await ZkTodoList.completeTodo(
      state.proof,
      Field(index),
      new Todo({
        text: CircuitString.fromString(text),
        status: Bool(false),
      })
    );
    todoRepr.status = true;
    state.merkleMap = proof.proof.publicOutput;
    state.objectRepr[index] = todoRepr;
    state.proof = proof.proof;
  },
  async completeTodos(indices: Array<number>) {
    for (const index of indices) {
      console.log("Completing todo", index);
      await this.completeTodo(index);
    }
  },
  getTodo(index: number) {
    return state.objectRepr[index];
  },
  getTodos() {
    return state.objectRepr;
  },
};

Comlink.expose(api);
```

And add the relevant wrappers to the worker client.

```ts
// todoListWorkerClient.ts

import * as Comlink from "comlink";

export default class TodoListWorkerClient {
  worker!: Worker;
  remoteApi: Comlink.Remote<typeof import("./todoListWorker").api>;

  constructor() {
    const worker = new Worker(new URL("./todoListWorker.ts", import.meta.url), {
      type: "module",
    });
    this.remoteApi = Comlink.wrap(worker);
  }

  async init() {
    await this.remoteApi.init();
  }

  async addTodos(todos: Array<string>) {
    await this.remoteApi.addTodos(todos);
  }

  async completeTodos(indices: Array<number>) {
    await this.remoteApi.completeTodos(indices);
  }

  async getTodo(index: number) {
    return await this.remoteApi.getTodo(index);
  }

  async getTodos() {
    return await this.remoteApi.getTodos();
  }
}
```

## Applying the UI

Rather than explain how to build a UI, I recommend grabbing the files from the complete example so you can use the app locally.  You'll note that it takes some time for the zk program to compile, but while it's compling, the app is usable.

## Deployment

Now that we have a complete app, here are the steps to deploy.  We will cover deployment to vercel and to Github Pages.

...
